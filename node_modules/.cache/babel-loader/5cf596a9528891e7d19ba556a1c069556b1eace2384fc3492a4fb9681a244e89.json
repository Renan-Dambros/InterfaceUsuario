{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/renan/ionic-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/renan/ionic-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { w as win, d as doc } from './index5.js';\nimport { K as Keyboard, a as KeyboardResize } from './keyboard.js';\n\n/**\n * The element that resizes when the keyboard opens\n * is going to depend on the resize mode\n * which is why we check that here.\n */\nvar getResizeContainer = function getResizeContainer(resizeMode) {\n  /**\n   * If doc is undefined then we are\n   * in an SSR environment, so the keyboard\n   * adjustment does not apply.\n   * If the webview does not resize then there\n   * is no container to resize.\n   */\n  if (doc === undefined || resizeMode === KeyboardResize.None || resizeMode === undefined) {\n    return null;\n  }\n  /**\n   * The three remaining resize modes: Native, Ionic, and Body\n   * all cause `ion-app` to resize, so we can listen for changes\n   * on that. In the event `ion-app` is not available then\n   * we can fall back to `body`.\n   */\n  var ionApp = doc.querySelector('ion-app');\n  return ionApp !== null && ionApp !== void 0 ? ionApp : doc.body;\n};\n/**\n * Get the height of ion-app or body.\n * This is used for determining if the webview\n * has resized before the keyboard closed.\n * */\nvar getResizeContainerHeight = function getResizeContainerHeight(resizeMode) {\n  var containerElement = getResizeContainer(resizeMode);\n  return containerElement === null ? 0 : containerElement.clientHeight;\n};\n/**\n * Creates a controller that tracks and reacts to opening or closing the keyboard.\n *\n * @internal\n * @param keyboardChangeCallback A function to call when the keyboard opens or closes.\n */\nvar createKeyboardController = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(keyboardChangeCallback) {\n    var keyboardWillShowHandler, keyboardWillHideHandler, keyboardVisible, initialResizeContainerHeight, init, fireChangeCallback, createResizePromiseIfNeeded, destroy, isKeyboardVisible;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          /**\n           * This lets us determine if the webview content\n           * has resized as a result of the keyboard.\n           */\n          init = /*#__PURE__*/function () {\n            var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n              var resizeOptions, resizeMode;\n              return _regeneratorRuntime().wrap(function _callee$(_context) {\n                while (1) switch (_context.prev = _context.next) {\n                  case 0:\n                    _context.next = 2;\n                    return Keyboard.getResizeMode();\n                  case 2:\n                    resizeOptions = _context.sent;\n                    resizeMode = resizeOptions === undefined ? undefined : resizeOptions.mode;\n                    keyboardWillShowHandler = function keyboardWillShowHandler() {\n                      /**\n                       * We need to compute initialResizeContainerHeight right before\n                       * the keyboard opens to guarantee the resize container is visible.\n                       * The resize container may not be visible if we compute this\n                       * as soon as the keyboard controller is created.\n                       * We should only need to do this once to avoid additional clientHeight\n                       * computations.\n                       */\n                      if (initialResizeContainerHeight === undefined) {\n                        initialResizeContainerHeight = getResizeContainerHeight(resizeMode);\n                      }\n                      keyboardVisible = true;\n                      fireChangeCallback(keyboardVisible, resizeMode);\n                    };\n                    keyboardWillHideHandler = function keyboardWillHideHandler() {\n                      keyboardVisible = false;\n                      fireChangeCallback(keyboardVisible, resizeMode);\n                    };\n                    win === null || win === void 0 ? void 0 : win.addEventListener('keyboardWillShow', keyboardWillShowHandler);\n                    win === null || win === void 0 ? void 0 : win.addEventListener('keyboardWillHide', keyboardWillHideHandler);\n                  case 8:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }, _callee);\n            }));\n            return function init() {\n              return _ref2.apply(this, arguments);\n            };\n          }();\n          fireChangeCallback = function fireChangeCallback(state, resizeMode) {\n            if (keyboardChangeCallback) {\n              keyboardChangeCallback(state, createResizePromiseIfNeeded(resizeMode));\n            }\n          };\n          /**\n           * Code responding to keyboard lifecycles may need\n           * to show/hide content once the webview has\n           * resized as a result of the keyboard showing/hiding.\n           * createResizePromiseIfNeeded provides a way for code to wait for the\n           * resize event that was triggered as a result of the keyboard.\n           */\n          createResizePromiseIfNeeded = function createResizePromiseIfNeeded(resizeMode) {\n            if (\n            /**\n             * If we are in an SSR environment then there is\n             * no window to resize. Additionally, if there\n             * is no resize mode or the resize mode is \"None\"\n             * then initialResizeContainerHeight will be 0\n             */\n            initialResizeContainerHeight === 0 ||\n            /**\n             * If the keyboard is closed before the webview resizes initially\n             * then the webview will never resize.\n             */\n            initialResizeContainerHeight === getResizeContainerHeight(resizeMode)) {\n              return;\n            }\n            /**\n             * Get the resize container so we can\n             * attach the ResizeObserver below to\n             * the correct element.\n             */\n            var containerElement = getResizeContainer(resizeMode);\n            if (containerElement === null) {\n              return;\n            }\n            /**\n             * Some part of the web content should resize,\n             * and we need to listen for a resize.\n             */\n            return new Promise(function (resolve) {\n              var callback = function callback() {\n                /**\n                 * As per the spec, the ResizeObserver\n                 * will fire when observation starts if\n                 * the observed element is rendered and does not\n                 * have a size of 0 x 0. However, the watched element\n                 * may or may not have resized by the time this first\n                 * callback is fired. As a result, we need to check\n                 * the dimensions of the element.\n                 *\n                 * https://www.w3.org/TR/resize-observer/#intro\n                 */\n                if (containerElement.clientHeight === initialResizeContainerHeight) {\n                  /**\n                   * The resize happened, so stop listening\n                   * for resize on this element.\n                   */\n                  ro.disconnect();\n                  resolve();\n                }\n              };\n              /**\n               * In Capacitor there can be delay between when the window\n               * resizes and when the container element resizes, so we cannot\n               * rely on a 'resize' event listener on the window.\n               * Instead, we need to determine when the container\n               * element resizes using a ResizeObserver.\n               */\n              var ro = new ResizeObserver(callback);\n              ro.observe(containerElement);\n            });\n          };\n          destroy = function destroy() {\n            win === null || win === void 0 ? void 0 : win.removeEventListener('keyboardWillShow', keyboardWillShowHandler);\n            win === null || win === void 0 ? void 0 : win.removeEventListener('keyboardWillHide', keyboardWillHideHandler);\n            keyboardWillShowHandler = keyboardWillHideHandler = undefined;\n          };\n          isKeyboardVisible = function isKeyboardVisible() {\n            return keyboardVisible;\n          };\n          _context2.next = 7;\n          return init();\n        case 7:\n          return _context2.abrupt(\"return\", {\n            init: init,\n            destroy: destroy,\n            isKeyboardVisible: isKeyboardVisible\n          });\n        case 8:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return function createKeyboardController(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport { createKeyboardController as c };","map":{"version":3,"names":["w","win","d","doc","K","Keyboard","a","KeyboardResize","getResizeContainer","resizeMode","undefined","None","ionApp","querySelector","body","getResizeContainerHeight","containerElement","clientHeight","createKeyboardController","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee2","keyboardChangeCallback","keyboardWillShowHandler","keyboardWillHideHandler","keyboardVisible","initialResizeContainerHeight","init","fireChangeCallback","createResizePromiseIfNeeded","destroy","isKeyboardVisible","wrap","_callee2$","_context2","prev","next","_ref2","_callee","resizeOptions","_callee$","_context","getResizeMode","sent","mode","addEventListener","stop","apply","arguments","state","Promise","resolve","callback","ro","disconnect","ResizeObserver","observe","removeEventListener","abrupt","_x","c"],"sources":["C:/Users/renan/ionic-app/node_modules/@ionic/core/components/keyboard-controller.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { w as win, d as doc } from './index5.js';\nimport { K as Keyboard, a as KeyboardResize } from './keyboard.js';\n\n/**\n * The element that resizes when the keyboard opens\n * is going to depend on the resize mode\n * which is why we check that here.\n */\nconst getResizeContainer = (resizeMode) => {\n  /**\n   * If doc is undefined then we are\n   * in an SSR environment, so the keyboard\n   * adjustment does not apply.\n   * If the webview does not resize then there\n   * is no container to resize.\n   */\n  if (doc === undefined || resizeMode === KeyboardResize.None || resizeMode === undefined) {\n    return null;\n  }\n  /**\n   * The three remaining resize modes: Native, Ionic, and Body\n   * all cause `ion-app` to resize, so we can listen for changes\n   * on that. In the event `ion-app` is not available then\n   * we can fall back to `body`.\n   */\n  const ionApp = doc.querySelector('ion-app');\n  return ionApp !== null && ionApp !== void 0 ? ionApp : doc.body;\n};\n/**\n * Get the height of ion-app or body.\n * This is used for determining if the webview\n * has resized before the keyboard closed.\n * */\nconst getResizeContainerHeight = (resizeMode) => {\n  const containerElement = getResizeContainer(resizeMode);\n  return containerElement === null ? 0 : containerElement.clientHeight;\n};\n/**\n * Creates a controller that tracks and reacts to opening or closing the keyboard.\n *\n * @internal\n * @param keyboardChangeCallback A function to call when the keyboard opens or closes.\n */\nconst createKeyboardController = async (keyboardChangeCallback) => {\n  let keyboardWillShowHandler;\n  let keyboardWillHideHandler;\n  let keyboardVisible;\n  /**\n   * This lets us determine if the webview content\n   * has resized as a result of the keyboard.\n   */\n  let initialResizeContainerHeight;\n  const init = async () => {\n    const resizeOptions = await Keyboard.getResizeMode();\n    const resizeMode = resizeOptions === undefined ? undefined : resizeOptions.mode;\n    keyboardWillShowHandler = () => {\n      /**\n       * We need to compute initialResizeContainerHeight right before\n       * the keyboard opens to guarantee the resize container is visible.\n       * The resize container may not be visible if we compute this\n       * as soon as the keyboard controller is created.\n       * We should only need to do this once to avoid additional clientHeight\n       * computations.\n       */\n      if (initialResizeContainerHeight === undefined) {\n        initialResizeContainerHeight = getResizeContainerHeight(resizeMode);\n      }\n      keyboardVisible = true;\n      fireChangeCallback(keyboardVisible, resizeMode);\n    };\n    keyboardWillHideHandler = () => {\n      keyboardVisible = false;\n      fireChangeCallback(keyboardVisible, resizeMode);\n    };\n    win === null || win === void 0 ? void 0 : win.addEventListener('keyboardWillShow', keyboardWillShowHandler);\n    win === null || win === void 0 ? void 0 : win.addEventListener('keyboardWillHide', keyboardWillHideHandler);\n  };\n  const fireChangeCallback = (state, resizeMode) => {\n    if (keyboardChangeCallback) {\n      keyboardChangeCallback(state, createResizePromiseIfNeeded(resizeMode));\n    }\n  };\n  /**\n   * Code responding to keyboard lifecycles may need\n   * to show/hide content once the webview has\n   * resized as a result of the keyboard showing/hiding.\n   * createResizePromiseIfNeeded provides a way for code to wait for the\n   * resize event that was triggered as a result of the keyboard.\n   */\n  const createResizePromiseIfNeeded = (resizeMode) => {\n    if (\n    /**\n     * If we are in an SSR environment then there is\n     * no window to resize. Additionally, if there\n     * is no resize mode or the resize mode is \"None\"\n     * then initialResizeContainerHeight will be 0\n     */\n    initialResizeContainerHeight === 0 ||\n      /**\n       * If the keyboard is closed before the webview resizes initially\n       * then the webview will never resize.\n       */\n      initialResizeContainerHeight === getResizeContainerHeight(resizeMode)) {\n      return;\n    }\n    /**\n     * Get the resize container so we can\n     * attach the ResizeObserver below to\n     * the correct element.\n     */\n    const containerElement = getResizeContainer(resizeMode);\n    if (containerElement === null) {\n      return;\n    }\n    /**\n     * Some part of the web content should resize,\n     * and we need to listen for a resize.\n     */\n    return new Promise((resolve) => {\n      const callback = () => {\n        /**\n         * As per the spec, the ResizeObserver\n         * will fire when observation starts if\n         * the observed element is rendered and does not\n         * have a size of 0 x 0. However, the watched element\n         * may or may not have resized by the time this first\n         * callback is fired. As a result, we need to check\n         * the dimensions of the element.\n         *\n         * https://www.w3.org/TR/resize-observer/#intro\n         */\n        if (containerElement.clientHeight === initialResizeContainerHeight) {\n          /**\n           * The resize happened, so stop listening\n           * for resize on this element.\n           */\n          ro.disconnect();\n          resolve();\n        }\n      };\n      /**\n       * In Capacitor there can be delay between when the window\n       * resizes and when the container element resizes, so we cannot\n       * rely on a 'resize' event listener on the window.\n       * Instead, we need to determine when the container\n       * element resizes using a ResizeObserver.\n       */\n      const ro = new ResizeObserver(callback);\n      ro.observe(containerElement);\n    });\n  };\n  const destroy = () => {\n    win === null || win === void 0 ? void 0 : win.removeEventListener('keyboardWillShow', keyboardWillShowHandler);\n    win === null || win === void 0 ? void 0 : win.removeEventListener('keyboardWillHide', keyboardWillHideHandler);\n    keyboardWillShowHandler = keyboardWillHideHandler = undefined;\n  };\n  const isKeyboardVisible = () => keyboardVisible;\n  await init();\n  return { init, destroy, isKeyboardVisible };\n};\n\nexport { createKeyboardController as c };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}