{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/renan/ionic-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { w as win } from './index5.js';\nimport { r as raf } from './helpers.js';\nimport { a as printIonError } from './index6.js';\n\n/**\n * Used to update a scoped component that uses emulated slots. This fires when\n * content is passed into the slot or when the content inside of a slot changes.\n * This is not needed for components using native slots in the Shadow DOM.\n * @internal\n * @param el The host element to observe\n * @param slotName mutationCallback will fire when nodes on this slot change\n * @param mutationCallback The callback to fire whenever the slotted content changes\n */\nvar createSlotMutationController = function createSlotMutationController(el, slotName, mutationCallback) {\n  var hostMutationObserver;\n  var slottedContentMutationObserver;\n  if (win !== undefined && 'MutationObserver' in win) {\n    hostMutationObserver = new MutationObserver(function (entries) {\n      var _iterator = _createForOfIteratorHelper(entries),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var entry = _step.value;\n          var _iterator2 = _createForOfIteratorHelper(entry.addedNodes),\n            _step2;\n          try {\n            var _loop = function _loop() {\n                var node = _step2.value;\n                /**\n                 * Check to see if the added node\n                 *  is our slotted content.\n                 */\n                if (node.nodeType === Node.ELEMENT_NODE && node.slot === slotName) {\n                  /**\n                   * If so, we want to watch the slotted\n                   * content itself for changes. This lets us\n                   * detect when content inside of the slot changes.\n                   */\n                  mutationCallback();\n                  /**\n                   * Adding the listener in an raf\n                   * waits until Stencil moves the slotted element\n                   * into the correct place in the event that\n                   * slotted content is being added.\n                   */\n                  raf(function () {\n                    return watchForSlotChange(node);\n                  });\n                  return {\n                    v: void 0\n                  };\n                }\n              },\n              _ret;\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              _ret = _loop();\n              if (_ret) return _ret.v;\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    });\n    hostMutationObserver.observe(el, {\n      childList: true\n    });\n  }\n  /**\n   * Listen for changes inside of the slotted content.\n   * We can listen for subtree changes here to be\n   * informed of text within the slotted content\n   * changing. Doing this on the host is possible\n   * but it is much more expensive to do because\n   * it also listens for changes to the internals\n   * of the component.\n   */\n  var watchForSlotChange = function watchForSlotChange(slottedEl) {\n    var _a;\n    if (slottedContentMutationObserver) {\n      slottedContentMutationObserver.disconnect();\n      slottedContentMutationObserver = undefined;\n    }\n    slottedContentMutationObserver = new MutationObserver(function (entries) {\n      mutationCallback();\n      var _iterator3 = _createForOfIteratorHelper(entries),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var entry = _step3.value;\n          var _iterator4 = _createForOfIteratorHelper(entry.removedNodes),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var node = _step4.value;\n              /**\n               * If the element was removed then we\n               * need to destroy the MutationObserver\n               * so the element can be garbage collected.\n               */\n              if (node.nodeType === Node.ELEMENT_NODE && node.slot === slotName) {\n                destroySlottedContentObserver();\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    });\n    /**\n     * Listen for changes inside of the element\n     * as well as anything deep in the tree.\n     * We listen on the parentElement so that we can\n     * detect when slotted element itself is removed.\n     */\n    slottedContentMutationObserver.observe((_a = slottedEl.parentElement) !== null && _a !== void 0 ? _a : slottedEl, {\n      subtree: true,\n      childList: true\n    });\n  };\n  var destroy = function destroy() {\n    if (hostMutationObserver) {\n      hostMutationObserver.disconnect();\n      hostMutationObserver = undefined;\n    }\n    destroySlottedContentObserver();\n  };\n  var destroySlottedContentObserver = function destroySlottedContentObserver() {\n    if (slottedContentMutationObserver) {\n      slottedContentMutationObserver.disconnect();\n      slottedContentMutationObserver = undefined;\n    }\n  };\n  return {\n    destroy: destroy\n  };\n};\nvar getCounterText = function getCounterText(value, maxLength, counterFormatter) {\n  var valueLength = value == null ? 0 : value.toString().length;\n  var defaultCounterText = defaultCounterFormatter(valueLength, maxLength);\n  /**\n   * If developers did not pass a custom formatter,\n   * use the default one.\n   */\n  if (counterFormatter === undefined) {\n    return defaultCounterText;\n  }\n  /**\n   * Otherwise, try to use the custom formatter\n   * and fallback to the default formatter if\n   * there was an error.\n   */\n  try {\n    return counterFormatter(valueLength, maxLength);\n  } catch (e) {\n    printIonError('Exception in provided `counterFormatter`.', e);\n    return defaultCounterText;\n  }\n};\nvar defaultCounterFormatter = function defaultCounterFormatter(length, maxlength) {\n  return \"\".concat(length, \" / \").concat(maxlength);\n};\nexport { createSlotMutationController as c, getCounterText as g };","map":{"version":3,"names":["w","win","r","raf","a","printIonError","createSlotMutationController","el","slotName","mutationCallback","hostMutationObserver","slottedContentMutationObserver","undefined","MutationObserver","entries","_iterator","_createForOfIteratorHelper","_step","s","n","done","entry","value","_iterator2","addedNodes","_step2","_loop","node","nodeType","Node","ELEMENT_NODE","slot","watchForSlotChange","v","_ret","err","e","f","observe","childList","slottedEl","_a","disconnect","_iterator3","_step3","_iterator4","removedNodes","_step4","destroySlottedContentObserver","parentElement","subtree","destroy","getCounterText","maxLength","counterFormatter","valueLength","toString","length","defaultCounterText","defaultCounterFormatter","maxlength","concat","c","g"],"sources":["C:/Users/renan/ionic-app/node_modules/@ionic/core/components/input.utils.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { w as win } from './index5.js';\nimport { r as raf } from './helpers.js';\nimport { a as printIonError } from './index6.js';\n\n/**\n * Used to update a scoped component that uses emulated slots. This fires when\n * content is passed into the slot or when the content inside of a slot changes.\n * This is not needed for components using native slots in the Shadow DOM.\n * @internal\n * @param el The host element to observe\n * @param slotName mutationCallback will fire when nodes on this slot change\n * @param mutationCallback The callback to fire whenever the slotted content changes\n */\nconst createSlotMutationController = (el, slotName, mutationCallback) => {\n  let hostMutationObserver;\n  let slottedContentMutationObserver;\n  if (win !== undefined && 'MutationObserver' in win) {\n    hostMutationObserver = new MutationObserver((entries) => {\n      for (const entry of entries) {\n        for (const node of entry.addedNodes) {\n          /**\n           * Check to see if the added node\n           *  is our slotted content.\n           */\n          if (node.nodeType === Node.ELEMENT_NODE && node.slot === slotName) {\n            /**\n             * If so, we want to watch the slotted\n             * content itself for changes. This lets us\n             * detect when content inside of the slot changes.\n             */\n            mutationCallback();\n            /**\n             * Adding the listener in an raf\n             * waits until Stencil moves the slotted element\n             * into the correct place in the event that\n             * slotted content is being added.\n             */\n            raf(() => watchForSlotChange(node));\n            return;\n          }\n        }\n      }\n    });\n    hostMutationObserver.observe(el, {\n      childList: true,\n    });\n  }\n  /**\n   * Listen for changes inside of the slotted content.\n   * We can listen for subtree changes here to be\n   * informed of text within the slotted content\n   * changing. Doing this on the host is possible\n   * but it is much more expensive to do because\n   * it also listens for changes to the internals\n   * of the component.\n   */\n  const watchForSlotChange = (slottedEl) => {\n    var _a;\n    if (slottedContentMutationObserver) {\n      slottedContentMutationObserver.disconnect();\n      slottedContentMutationObserver = undefined;\n    }\n    slottedContentMutationObserver = new MutationObserver((entries) => {\n      mutationCallback();\n      for (const entry of entries) {\n        for (const node of entry.removedNodes) {\n          /**\n           * If the element was removed then we\n           * need to destroy the MutationObserver\n           * so the element can be garbage collected.\n           */\n          if (node.nodeType === Node.ELEMENT_NODE && node.slot === slotName) {\n            destroySlottedContentObserver();\n          }\n        }\n      }\n    });\n    /**\n     * Listen for changes inside of the element\n     * as well as anything deep in the tree.\n     * We listen on the parentElement so that we can\n     * detect when slotted element itself is removed.\n     */\n    slottedContentMutationObserver.observe((_a = slottedEl.parentElement) !== null && _a !== void 0 ? _a : slottedEl, { subtree: true, childList: true });\n  };\n  const destroy = () => {\n    if (hostMutationObserver) {\n      hostMutationObserver.disconnect();\n      hostMutationObserver = undefined;\n    }\n    destroySlottedContentObserver();\n  };\n  const destroySlottedContentObserver = () => {\n    if (slottedContentMutationObserver) {\n      slottedContentMutationObserver.disconnect();\n      slottedContentMutationObserver = undefined;\n    }\n  };\n  return {\n    destroy,\n  };\n};\n\nconst getCounterText = (value, maxLength, counterFormatter) => {\n  const valueLength = value == null ? 0 : value.toString().length;\n  const defaultCounterText = defaultCounterFormatter(valueLength, maxLength);\n  /**\n   * If developers did not pass a custom formatter,\n   * use the default one.\n   */\n  if (counterFormatter === undefined) {\n    return defaultCounterText;\n  }\n  /**\n   * Otherwise, try to use the custom formatter\n   * and fallback to the default formatter if\n   * there was an error.\n   */\n  try {\n    return counterFormatter(valueLength, maxLength);\n  }\n  catch (e) {\n    printIonError('Exception in provided `counterFormatter`.', e);\n    return defaultCounterText;\n  }\n};\nconst defaultCounterFormatter = (length, maxlength) => {\n  return `${length} / ${maxlength}`;\n};\n\nexport { createSlotMutationController as c, getCounterText as g };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}